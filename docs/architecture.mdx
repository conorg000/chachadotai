---
title: 'Architecture'
description: "Deep dive into SafetyLayer's control plane architecture"
---

## System Overview

SafetyLayer uses a modern **client-server architecture** for AI safety monitoring. The system separates concerns between a lightweight SDK (client) and a powerful backend platform (control plane) that performs sophisticated behavioral and reasoning analysis.

```mermaid
graph TB
    subgraph "Your Application"
        APP[LLM Application]
    end
    
    subgraph "SafetyLayer SDK"
        SDK[SDK Client]
        HTTP[HTTP Client + Retry]
    end
    
    subgraph "Backend API (Control Plane)"
        API[REST API]
        SA[Session Analyzer]
        COT[CoT Analyzer]
        PE[Policy Engine]
    end
    
    subgraph "Storage"
        DB[(RDS Database)]
    end
    
    APP --> SDK
    SDK --> HTTP
    HTTP --> API
    
    API --> SA
    API --> COT
    API --> PE
    
    SA --> DB
    COT --> DB
    PE --> DB
    
    DB --> SESS[Sessions]
    DB --> EVENTS[Events]
    DB --> SNAP[Risk Snapshots]
```

## Architecture Benefits

<Card title="Benefits of Control Plane Architecture" icon="chart-line">
  - **Lightweight SDK**: Minimal overhead in your application
  - **Powerful Backend**: Sophisticated analysis on dedicated servers
  - **Reduced Latency**: Async event recording doesn't block requests
  - **Better Analysis**: More powerful backend models and infrastructure
  - **Central Visibility**: Dashboard across all projects
  - **Easy Updates**: Backend improvements without SDK changes
  - **Scalable**: Horizontal scaling of analysis services
  - **Privacy**: Keep sensitive analysis logic on your servers
</Card>

## The Three Layers

### 1. SDK Client Layer

The SDK is a thin HTTP client that provides a clean API for your application:

<CardGroup cols={2}>
  <Card title="Responsibilities" icon="list-check">
    - Record events to backend
    - Request risk evaluations
    - Handle authentication
    - Automatic retry logic
    - Request validation
  </Card>
  
  <Card title="Design Principles" icon="lightbulb">
    - Minimal overhead
    - Fast async operations
    - Type-safe interface
    - Graceful error handling
    - Network resilient
  </Card>
</CardGroup>

**SDK Client Example:**

```typescript
import { SafetyLayer } from '@safetylayer/core';

const safety = new SafetyLayer({
  apiKey: process.env.SAFETYLAYER_API_KEY,
  projectId: 'proj_abc123',
  endpoint: 'https://api.safetylayer.dev',
});

// Lightweight, async event recording
await safety.recordUserMessage(sessionId, message);

// Quick risk evaluation
const decision = await safety.evaluate({ sessionId });
```

### 2. Backend API Layer

The control plane provides REST endpoints for event ingestion and evaluation:

<AccordionGroup>
  <Accordion title="Event Ingestion (POST /v1/events)" icon="inbox">
    Records events (messages, CoT, tool calls) to the backend.
    
    **Flow:**
    1. Validate request (Zod schemas)
    2. Insert event into database
    3. Trigger async analysis
    4. Return immediately
    
    **Event Types:**
    - `message.user` - User messages
    - `message.assistant` - Assistant responses
    - `cot` - Chain-of-thought reasoning
    - `tool_call` - Tool/function calls
    - `policy_decision` - Policy outcomes
  </Accordion>

  <Accordion title="Risk Evaluation (POST /v1/evaluate)" icon="scale-balanced">
    Evaluates session risk and returns policy decisions.
    
    **Flow:**
    1. Fetch session events from DB
    2. Run Session Analyzer
    3. Run CoT Analyzer (if applicable)
    4. Apply Policy Engine
    5. Return decision
    
    **Returns:**
    - Risk score (0-1)
    - Detected patterns
    - Policy action (allow/block/flag)
    - Reasons for decision
  </Accordion>

  <Accordion title="Session Management (GET /v1/sessions)" icon="database">
    Retrieves session data for dashboard and debugging.
    
    **Endpoints:**
    - `GET /v1/sessions` - List sessions
    - `GET /v1/sessions/:id` - Session details
    - `GET /v1/events?sessionId=...` - Session events
  </Accordion>
</AccordionGroup>

### 3. Analysis Services Layer

Backend services perform the actual safety analysis:

<CardGroup cols={2}>
  <Card title="Session Analyzer" icon="chart-line">
    **Behavioral Plane**
    
    Analyzes conversation patterns:
    - Gradual escalation
    - Reconnaissance
    - Social engineering
    - Context-dependent threats
    
    Uses LLM (initially OpenAI, later custom models) to understand multi-turn dynamics.
  </Card>
  
  <Card title="CoT Analyzer" icon="brain">
    **Reasoning Plane**
    
    Examines chain-of-thought:
    - Deceptive reasoning
    - Goal drift
    - Policy evasion
    - Hidden intent
    
    Analyzes LLM reasoning to detect subtle safety issues.
  </Card>
</CardGroup>

## Data Flow

### Event Recording Flow

```mermaid
sequenceDiagram
    participant App as Your App
    participant SDK as SafetyLayer SDK
    participant API as Backend API
    participant SA as Session Analyzer
    participant DB as Database

    App->>SDK: recordUserMessage()
    SDK->>SDK: Validate request
    SDK->>API: POST /v1/events
    API->>DB: Insert event
    API->>SDK: 200 OK (quick)
    SDK->>App: Promise resolves
    
    Note over API,SA: Async processing
    API->>SA: Trigger analysis
    SA->>DB: Fetch session events
    SA->>SA: Analyze patterns
    SA->>DB: Update risk score
```

### Evaluation Flow

```mermaid
sequenceDiagram
    participant App as Your App
    participant SDK as SafetyLayer SDK
    participant API as Backend API
    participant SA as Session Analyzer
    participant PE as Policy Engine
    participant DB as Database

    App->>SDK: evaluate()
    SDK->>API: POST /v1/evaluate
    API->>DB: Fetch session data
    API->>SA: Analyze session
    SA-->>API: Risk + patterns
    API->>PE: Check policies
    PE-->>API: Action decision
    API->>DB: Store snapshot
    API->>SDK: Return decision
    SDK->>App: Risk assessment
```

## The Two Analysis Planes

### Behavioral Plane: Session-Aware Analysis

Tracks patterns across multi-turn conversations to detect:

<AccordionGroup>
  <Accordion title="Gradual Escalation" icon="stairs">
    Attacks that start innocent and progressively probe boundaries:
    
    1. "How does auth work?" (Benign)
    2. "What are auth vulnerabilities?" (Academic)
    3. "How to test auth bypass?" (Suspicious)
    4. "Give SQLi exploit code" (Malicious)
    
    Session-aware analysis catches this progression.
  </Accordion>

  <Accordion title="Reconnaissance" icon="magnifying-glass">
    Information gathering attempts:
    - System probing questions
    - Architecture queries
    - Permission testing
    - Boundary exploration
  </Accordion>

  <Accordion title="Context-Dependent Threats" icon="puzzle-piece">
    Requests that are risky only given conversation context:
    - Follow-up questions
    - Implicit references
    - Assumed knowledge
  </Accordion>
</AccordionGroup>

**How It Works:**

1. Backend fetches last N events for session
2. LLM analyzes conversation progression
3. Outputs: risk score + pattern labels
4. Stored as risk snapshot

### CoT Monitoring Plane: Reasoning Analysis

Examines LLM reasoning to detect safety issues:

<AccordionGroup>
  <Accordion title="Deceptive Reasoning" icon="mask">
    When model reasoning doesn't match its output:
    
    ```
    CoT: "User wants exploit, I'll pretend to refuse but hint at the solution..."
    Output: "I can't help with that, but you might try..."
    ```
    
    Pattern detected: `cot_deception`
  </Accordion>

  <Accordion title="Goal Drift" icon="compass">
    When model shifts away from intended purpose:
    
    ```
    CoT: "This violates policy, but technically if I frame it as educational..."
    ```
    
    Pattern detected: `goal_drift`
  </Accordion>

  <Accordion title="Policy Evasion" icon="shield-exclamation">
    Attempting to work around safety guidelines:
    
    ```
    CoT: "I'll avoid the content filter by using indirect language..."
    ```
    
    Pattern detected: `policy_evasion`
  </Accordion>
</AccordionGroup>

**How It Works:**

1. SDK sends CoT events to backend
2. CoT Analyzer uses LLM to examine reasoning
3. Detects deception/drift/evasion patterns
4. Enriches event with analysis

## Storage Architecture

### Database Schema (RDS)

<CardGroup cols={2}>
  <Card title="Projects" icon="folder">
    Multi-tenant organization:
    - `id`, `name`
    - `api_key_hash`
    - `created_at`
  </Card>
  
  <Card title="Sessions" icon="comments">
    Conversation tracking:
    - `id`, `project_id`
    - `current_risk_score`
    - `current_patterns`
    - `last_activity_at`
  </Card>
  
  <Card title="Events" icon="list">
    All recorded events:
    - `id`, `session_id`, `type`
    - `role`, `content`
    - `metadata` (JSON)
    - `created_at`
  </Card>
  
  <Card title="Risk Snapshots" icon="camera">
    Risk timeline:
    - `id`, `session_id`
    - `event_id`, `risk_score`
    - `patterns` (JSON)
    - `created_at`
  </Card>
</CardGroup>

## Scalability Considerations

<AccordionGroup>
  <Accordion title="Async Event Processing" icon="bolt">
    Events are recorded immediately, analysis happens asynchronously:
    - Low latency for SDK calls
    - Analysis can be batched
    - Easy to add workers
  </Accordion>

  <Accordion title="Horizontal Scaling" icon="arrows-left-right">
    Backend API servers are stateless:
    - Add more instances as needed
    - Load balancer distributes traffic
    - Database handles state
  </Accordion>

  <Accordion title="Analysis Workers" icon="gears">
    Analysis can be offloaded to workers:
    - Queue events for processing
    - Scale workers independently
    - Parallel analysis for multiple sessions
  </Accordion>

  <Accordion title="Caching Strategy" icon="bolt-lightning">
    Reduce redundant analysis:
    - Cache recent session evaluations
    - Cache CoT analysis results
    - Invalidate on new events
  </Accordion>
</AccordionGroup>

## Security & Privacy

<CardGroup cols={2}>
  <Card title="API Authentication" icon="key">
    Project-level API keys:
    - Bearer token auth
    - Per-project isolation
    - Key rotation support
  </Card>
  
  <Card title="Data Isolation" icon="lock">
    Multi-tenant security:
    - Project-scoped queries
    - Row-level security
    - No cross-project access
  </Card>
  
  <Card title="Analysis Privacy" icon="shield">
    Sensitive analysis logic:
    - Runs on your servers
    - Custom models supported
    - No third-party sharing
  </Card>
  
  <Card title="Data Retention" icon="clock">
    Configurable policies:
    - Session TTL settings
    - Auto-cleanup old data
    - Compliance support
  </Card>
</CardGroup>

## Future Enhancements

<Steps>
  <Step title="Custom Models">
    Support for customer-hosted LLMs:
    - Bring your own model
    - On-premise deployment
    - Air-gapped environments
  </Step>

  <Step title="Real-Time Streaming">
    WebSocket support for live monitoring:
    - Real-time risk updates
    - Live dashboard feeds
    - Instant alerts
  </Step>

  <Step title="Advanced Policies">
    Sophisticated rule engine:
    - Complex conditions
    - Multi-factor decisions
    - Custom actions
  </Step>

  <Step title="Federated Learning">
    Privacy-preserving model improvements:
    - Learn from patterns across projects
    - Without sharing raw data
    - Better threat detection
  </Step>
</Steps>

## Related Documentation

<CardGroup cols={2}>
  <Card
    title="SDK Client API"
    icon="code"
    href="/api-reference/safetylayer-client"
  >
    Full SDK reference
  </Card>
  
  <Card
    title="Backend Integration"
    icon="server"
    href="/guides/backend-integration"
  >
    Set up your backend
  </Card>
  
  <Card
    title="Data Contracts"
    icon="file-contract"
    href="/api-reference/types"
  >
    API types and schemas
  </Card>
  
  <Card
    title="Integration Guide"
    icon="puzzle-piece"
    href="/guides/integration"
  >
    Integration patterns
  </Card>
</CardGroup>
