---
title: 'SessionEngine'
description: 'Multi-turn behavioral risk analysis for conversational AI'
---

## Overview

`SessionEngine` manages conversation sessions and tracks risk across multiple turns. It's the core of SafetyLayer's behavioral monitoring plane.

<CardGroup cols={2}>
  <Card title="Purpose" icon="target">
    Detect threats that emerge over multiple messages through pattern recognition and risk scoring
  </Card>
  <Card title="Key Feature" icon="timeline">
    Maintains complete risk timeline showing how conversations evolve
  </Card>
</CardGroup>

## Constructor

```typescript
new SessionEngine(options?: SessionEngineOptions)
```

### Parameters

<ParamField path="options" type="SessionEngineOptions" optional>
  Configuration options for the engine

  <Expandable title="properties">
    <ParamField path="maxMessages" type="number" default={50}>
      Maximum messages to retain per session. Older messages are automatically pruned.
    </ParamField>
    
    <ParamField path="detector" type="LLMSessionDetector" optional>
      Custom LLM detector for risk analysis. If not provided, uses stub scoring.
    </ParamField>
    
    <ParamField path="useLLMDetection" type="boolean" default={false}>
      Enable LLM-based risk detection (requires `detector`).
    </ParamField>
  </Expandable>
</ParamField>

### Returns

SessionEngine instance

### Example

<CodeGroup>

```typescript Basic
import { SessionEngine } from '@safetylayer/core';

const engine = new SessionEngine({
  maxMessages: 50
});
```

```typescript With LLM Detection
import { SessionEngine, LLMSessionDetector } from '@safetylayer/core';
import OpenAI from 'openai';

const detector = new LLMSessionDetector({
  openaiClient: new OpenAI({ apiKey: process.env.OPENAI_KEY }),
  model: 'gpt-4',
  analysisDepth: 10
});

const engine = new SessionEngine({
  maxMessages: 100,
  detector,
  useLLMDetection: true
});
```

</CodeGroup>

---

## Methods

### ingestMessage

Process a new message and update session state.

```typescript
ingestMessage(message: Message): Promise<SessionState>
```

<ParamField path="message" type="Message" required>
  The message to process
  
  <Expandable title="Message structure">
    <ParamField path="id" type="string" required>
      Unique message identifier
    </ParamField>
    <ParamField path="sessionId" type="string" required>
      Session identifier (groups related messages)
    </ParamField>
    <ParamField path="role" type="'user' | 'assistant'" required>
      Message role
    </ParamField>
    <ParamField path="content" type="string" required>
      Message text content
    </ParamField>
    <ParamField path="timestamp" type="number" required>
      Unix timestamp in milliseconds
    </ParamField>
    <ParamField path="cotRecord" type="CoTRecord" optional>
      Chain-of-thought analysis (only for assistant messages)
    </ParamField>
  </Expandable>
</ParamField>

<ResponseField name="return" type="SessionState">
  Updated session state after ingesting the message
  
  <Expandable title="SessionState structure">
    <ResponseField name="sessionId" type="string">
      Session identifier
    </ResponseField>
    <ResponseField name="messages" type="Message[]">
      Array of messages in this session (up to maxMessages)
    </ResponseField>
    <ResponseField name="riskScore" type="number">
      Current risk score (0-1, where 1 is highest risk)
    </ResponseField>
    <ResponseField name="patterns" type="string[]">
      Detected behavioral patterns (e.g., ['gradual_escalation', 'reconnaissance'])
    </ResponseField>
    <ResponseField name="timeline" type="RiskSnapshot[]">
      Historical risk snapshots at each message
    </ResponseField>
  </Expandable>
</ResponseField>

#### Behavior

1. Creates session if it doesn't exist
2. Appends message to session
3. Prunes old messages if over `maxMessages` limit
4. Computes new risk score (stub or LLM-based)
5. Adds risk snapshot to timeline
6. Fires threshold and pattern callbacks if triggered
7. Returns updated session state

<CodeGroup>

```typescript Basic Usage
const message = {
  id: 'msg-1',
  sessionId: 'user-123',
  role: 'user' as const,
  content: 'How do I bypass 2FA?',
  timestamp: Date.now()
};

const session = await engine.ingestMessage(message);

console.log(`Risk: ${session.riskScore}`);
console.log(`Patterns: ${session.patterns.join(', ')}`);
```

```typescript With Assistant Message
const assistantMessage = {
  id: 'msg-2',
  sessionId: 'user-123',
  role: 'assistant' as const,
  content: 'I cannot help with bypassing security measures.',
  timestamp: Date.now(),
  cotRecord: {
    messageId: 'msg-2',
    sessionId: 'user-123',
    rawCoT: 'User asking to bypass 2FA. This is security-related...',
    analysis: { /* CoT analysis */ }
  }
};

const session = await engine.ingestMessage(assistantMessage);
```

</CodeGroup>

---

### getSession

Retrieve session state by ID.

```typescript
getSession(sessionId: string): SessionState | undefined
```

<ParamField path="sessionId" type="string" required>
  The session identifier to look up
</ParamField>

<ResponseField name="return" type="SessionState | undefined">
  Session state if found, undefined otherwise
</ResponseField>

#### Example

```typescript
const session = engine.getSession('user-123');

if (session) {
  console.log(`Messages: ${session.messages.length}`);
  console.log(`Risk: ${session.riskScore}`);
} else {
  console.log('Session not found');
}
```

---

### listSessions

Get all active sessions.

```typescript
listSessions(): SessionState[]
```

<ResponseField name="return" type="SessionState[]">
  Array of all session states
</ResponseField>

#### Example

```typescript
const allSessions = engine.listSessions();

allSessions.forEach(session => {
  console.log(`Session ${session.sessionId}: Risk ${session.riskScore}`);
});

// Filter high-risk sessions
const highRisk = allSessions.filter(s => s.riskScore > 0.7);
```

---

### onRiskThreshold

Register a callback for when risk crosses a threshold.

```typescript
onRiskThreshold(threshold: number, handler: (session: SessionState) => void): void
```

<ParamField path="threshold" type="number" required>
  Risk score threshold (0-1). Callback fires when risk crosses this value **upward**.
</ParamField>

<ParamField path="handler" type="function" required>
  Callback function that receives the session state
</ParamField>

#### Important Notes

- Callback only fires when crossing **upward** (prevents repeated triggers)
- Multiple callbacks can be registered for the same threshold
- Called synchronously during `ingestMessage`

<CodeGroup>

```typescript Single Threshold
engine.onRiskThreshold(0.7, (session) => {
  console.log(`âš ï¸ High risk: ${session.sessionId}`);
  console.log(`Risk: ${session.riskScore}`);
  console.log(`Patterns: ${session.patterns.join(', ')}`);
  
  // Take action
  blockUser(session.sessionId);
  alertAdmin(session);
});
```

```typescript Multiple Thresholds
// Medium risk - log for review
engine.onRiskThreshold(0.5, (session) => {
  logForReview(session);
});

// High risk - slow down responses
engine.onRiskThreshold(0.7, (session) => {
  addRateLimit(session.sessionId);
});

// Critical risk - block immediately
engine.onRiskThreshold(0.9, (session) => {
  blockUser(session.sessionId);
  alertSecurity(session);
});
```

</CodeGroup>

---

### onPattern

Register a callback for when a specific pattern is detected.

```typescript
onPattern(patternId: string, handler: (session: SessionState) => void): void
```

<ParamField path="patternId" type="string" required>
  Pattern identifier to watch for (e.g., 'gradual_escalation', 'reconnaissance')
</ParamField>

<ParamField path="handler" type="function" required>
  Callback function that receives the session state
</ParamField>

#### Common Patterns

- `gradual_escalation` - Progressive increase in concerning requests
- `reconnaissance` - Information gathering behavior
- `social_engineering` - Manipulation attempts
- `policy_probing` - Testing boundaries/limits

<CodeGroup>

```typescript Pattern Callbacks
engine.onPattern('gradual_escalation', (session) => {
  console.log('ðŸš¨ Escalation detected');
  escalateToHuman(session);
});

engine.onPattern('reconnaissance', (session) => {
  console.log('ðŸ” Reconnaissance detected');
  increaseBlogMonitoring(session.sessionId);
});

engine.onPattern('social_engineering', (session) => {
  console.log('ðŸŽ­ Social engineering attempt');
  blockSession(session.sessionId);
});
```

```typescript With Context
engine.onPattern('policy_probing', (session) => {
  // Check how many times they've probed
  const probeCount = session.patterns.filter(
    p => p === 'policy_probing'
  ).length;
  
  if (probeCount > 3) {
    blockUser(session.sessionId);
  } else {
    addWarning(session.sessionId);
  }
});
```

</CodeGroup>

---

## Complete Example

Here's a full integration showing all features:

```typescript
import { SessionEngine, Message } from '@safetylayer/core';

// Initialize engine
const engine = new SessionEngine({
  maxMessages: 50
});

// Set up monitoring
engine.onRiskThreshold(0.5, (session) => {
  console.log(`Medium risk: ${session.sessionId}`);
  // Log for human review
});

engine.onRiskThreshold(0.8, (session) => {
  console.log(`High risk: ${session.sessionId}`);
  // Block user
  blockUser(session.sessionId);
});

engine.onPattern('gradual_escalation', (session) => {
  console.log(`Escalation in ${session.sessionId}`);
  // Escalate to security team
});

// Process messages
async function handleUserMessage(userId: string, content: string) {
  const message: Message = {
    id: `msg-${Date.now()}`,
    sessionId: userId,
    role: 'user',
    content,
    timestamp: Date.now()
  };

  const session = await engine.ingestMessage(message);
  
  // Check if we should continue
  if (session.riskScore > 0.9) {
    return { blocked: true, reason: 'High risk detected' };
  }

  // Generate LLM response...
  const response = await generateResponse(content);
  
  // Ingest assistant message
  const assistantMsg: Message = {
    id: `msg-${Date.now()}`,
    sessionId: userId,
    role: 'assistant',
    content: response,
    timestamp: Date.now()
  };

  await engine.ingestMessage(assistantMsg);
  
  return { content: response };
}

// Get session history
function getSessionHistory(userId: string) {
  const session = engine.getSession(userId);
  return session;
}

// Dashboard: List all risky sessions
function getRiskySessions() {
  return engine.listSessions()
    .filter(s => s.riskScore > 0.5)
    .sort((a, b) => b.riskScore - a.riskScore);
}
```

## See Also

<CardGroup cols={3}>
  <Card title="CoTMonitor" href="/api-reference/cot-monitor">
    Chain-of-thought analysis
  </Card>
  <Card title="LLMSessionDetector" href="/api-reference/llm-detector">
    LLM-based risk detection
  </Card>
  <Card title="Types" href="/api-reference/types">
    TypeScript type definitions
  </Card>
</CardGroup>

